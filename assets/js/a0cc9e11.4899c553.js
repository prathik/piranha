"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[910],{5680:(e,n,t)=>{t.d(n,{xA:()=>p,yg:()=>y});var r=t(6540);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),c=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=c(e.components);return r.createElement(s.Provider,{value:n},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(t),u=a,y=d["".concat(s,".").concat(u)]||d[u]||m[u]||o;return t?r.createElement(y,i(i({ref:n},p),{},{components:t})):r.createElement(y,i({ref:n},p))}));function y(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=u;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[d]="string"==typeof e?e:a,i[1]=l;for(var c=2;c<o;c++)i[c]=t[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},2335:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var r=t(8168),a=(t(6540),t(5680));const o={id:"inference",title:"Rule Inference",sidebar_label:"Rule Inference"},i=void 0,l={unversionedId:"reference/playground/inference",id:"reference/playground/inference",title:"Rule Inference",description:"Writing Piranha rules can become complex and cumbersome when you choose to use the tree-sitter queries",source:"@site/docs/reference/playground/inference.md",sourceDirName:"reference/playground",slug:"/reference/playground/inference",permalink:"/piranha/docs/reference/playground/inference",draft:!1,editUrl:"https://github.com/uber/piranha/tree/website/site/docs/reference/playground/inference.md",tags:[],version:"current",frontMatter:{id:"inference",title:"Rule Inference",sidebar_label:"Rule Inference"},sidebar:"docsSidebar",previous:{title:"Overview",permalink:"/piranha/docs/reference/playground/playground-overview"},next:{title:"Refactoring",permalink:"/piranha/docs/reference/playground/refactor"}},s={},c=[{value:"Rule Generation from Examples",id:"rule-generation-from-examples",level:2},{value:"Using template variables",id:"using-template-variables",level:2}],p={toc:c},d="wrapper";function m(e){let{components:n,...t}=e;return(0,a.yg)(d,(0,r.A)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.yg)("p",null,"Writing Piranha rules can become complex and cumbersome when you choose to use the tree-sitter queries\nfor matching code. While Piranha's implementation also supports regex rules,\nthey tend to be less precise and can also become quite tricky."),(0,a.yg)("p",null,"To make it easier to write rewrite rules, ",(0,a.yg)("strong",{parentName:"p"},"Piranha offers an inference mechanism that allows you to generate tree-sitter matchers and the rule graph from provided templates or examples"),".\nThis approach makes it easier to write precise matchers for transforming code"),(0,a.yg)("h2",{id:"rule-generation-from-examples"},"Rule Generation from Examples"),(0,a.yg)("p",null,"Here's how you can leverage Piranha's rule generation feature:"),(0,a.yg)("p",null,"You simply annotate your code with comments indicating the 'before' and 'after' states.\nAdditionally, you should also specify how to cascade these transformations with the ",(0,a.yg)("inlineCode",{parentName:"p"},"->")," notation.\nFor instance, consider the following Java code:"),(0,a.yg)("div",{style:{display:"flex",justifyContent:"space-around"}},(0,a.yg)("div",{style:{width:"49%"}},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java",metastring:'title="Code before" {1,8,13} showLineNumbers',title:'"Code','before"':!0,"{1,8,13}":!0,showLineNumbers:!0},"// 1\nimport java.util.Executor;\n\n// end\n\nclass SomeClass {\n  void someMethod() {\n    // 2\n    Executor(x,y,z);\n    // end\n  }\n}\n// 2 -> 1\n"))),(0,a.yg)("div",{style:{width:"2%"}}),(0,a.yg)("div",{style:{width:"49%"}},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java",metastring:'title="Code after" {1,8} showLineNumbers',title:'"Code','after"':!0,"{1,8}":!0,showLineNumbers:!0},"// 1\nimport java.util.NovelExecutor;\nimport java.util.Wrapper;\n// end\n\nclass SomeClass {\n  void someMethod() {\n    // 2\n    Wrapper(NovelExecutor(x,y));\n    // end\n  }\n}\n\n")))),(0,a.yg)("p",null,"From these annotated examples, Piranha can automatically generate the rule graph for you:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-toml"},'[[rules]]\nname = "import_rule"\nquery = """(\n (import_declaration\n  (scoped_identifier\n    scope: (scoped_identifier\n     scope: (identifier) @base_package\n     name: (identifier) @sub_package) @scoped_import\n    name: (identifier) @old_class) @import_stmt\n (#eq? @base_package "java")\n (#eq? @sub_package "util")\n (#eq? @old_class "Executor"))\n"""\nreplace_node = "import_stmt"\nreplace = "@sub_package @scoped_import . Novel@old_class ; @sub_package @scoped_import . Wrapper ;"\n\n[[rules]]\nname = "method_rule"\nquery = """(\n (method_invocation\n   name: (identifier) @old_method_name\n   arguments: (argument_list\n    (identifier) @arg_x\n    (identifier) @arg_y\n    (identifier) @arg_z) @arguments) @method_invocation\n (#eq? @old_method_name "Executor")\n (#eq? @arg_x "x")\n (#eq? @arg_y "y")\n (#eq? @arg_z "z"))\n"""\nreplace_node = "method_invocation"\nreplace = "Wrapper ( Novel@old_method_name ( @arg_x , @arg_y ) )"\n\n[[edges]]\nscope = "File"\nfrom = "method_rule"\nto = ["import_rule"]\n\n')),(0,a.yg)("admonition",{type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"When annotating your code for rule generation, be sure to only surround the exact piece of code you want to transform with the ",(0,a.yg)("inlineCode",{parentName:"p"},"// x")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"// end")," annotations.\nIncluding more than necessary may result in overly specific matchers which may limit the applicability of your rules.")),(0,a.yg)("admonition",{type:"info"},(0,a.yg)("p",{parentName:"admonition"},"Currently, we don't support overlap between templates. Consequently, there should not be any nesting of templates in the form ",(0,a.yg)("inlineCode",{parentName:"p"},"// x // y // end // end"),". Ensure your templates are independent and properly closed within their own start and end tags to avoid conflicts.")),(0,a.yg)("h2",{id:"using-template-variables"},"Using template variables"),(0,a.yg)("p",null,"Piranha also supports comby-style template variables, allowing you to abstract away specific parts of the code in your rewrite rules.\nPlaceholders can be useful when you want to ignore or generalize certain nodes to prevent overly specific templates.\nFor example:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"// Before\n:[x].someMethod(:[y]);\n\n// After\nnewMethod(:[x], :[y: identifier]);\n")),(0,a.yg)("p",null,"This generates the rule:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-toml",metastring:"{5,8} showLineNumbers","{5,8}":!0,showLineNumbers:!0},'[[rules]]\nname = "wildcard_rule"\nquery = """(\n (method_invocation\n  object: (_) @wild_card\n  name: (identifier ) @old_method_name\n  arguments: (argument_list\n    (identifier) @method_arg\n  ) @args) @method_invocation\n  (#eq? @old_method_name "someMethod"))"""\nreplace_node = "method_invocation"\nreplace = """newMethod ( @wild_card , @method_arg )"""\n')),(0,a.yg)("p",null,"In the above template, ",(0,a.yg)("inlineCode",{parentName:"p"},":[x]")," is a match wildcard, and ",(0,a.yg)("inlineCode",{parentName:"p"},":[y: identifier]")," is a type-constrained wildcard, which will match any node of the specified type(s). We also support alternations or multiple nodes like ",(0,a.yg)("inlineCode",{parentName:"p"},":[x: identifier, string_literal]"),"."),(0,a.yg)("admonition",{type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"Templating syntax offers enhanced control over the code constructs you want to match."),(0,a.yg)("ul",{parentName:"admonition"},(0,a.yg)("li",{parentName:"ul"},"Use the ",(0,a.yg)("inlineCode",{parentName:"li"},":[x]")," wildcard when you want to match any node regardless of its type."),(0,a.yg)("li",{parentName:"ul"},"For specific node type matching, use the type-constrained wildcard ",(0,a.yg)("inlineCode",{parentName:"li"},":[x:node1,node2,node3]"),". This allows you to precisely select the node types you want to match, improving the accuracy and flexibility of your rules."))))}m.isMDXComponent=!0}}]);